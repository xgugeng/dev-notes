<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

1、应对C语言标准变更：没看明白，估计是已经过时了，他说编译过不了的程序在我看来是如此的正常。
2、标识符名称的限制：这个应该也是过时。
3、整数的大小
	3.1、定义一个可以存放千万数量级的数值
	typedef long tenmil;
	3.2、如果定义的整数跟位数有关，如需要一个无符号32位整数，则
        3.2.1、这是因为int的位数与机器有关，这样可以增强可移植性，把类型定义放在头文件中
        ```c++
        typedef uint32 int;
        typedef uint32_p *uint32;
        ```
4、字符是有符号整数还是无符号整数
    4.1、在字符向整数扩展时，如果字符的最高位为1，则有符号扩展，否则进行无符号扩展
5、位移运算符
    5.1、右移时，有符号数补符号位，无符号数补0，默认是有符号数
    5.2、移位计数允许的取值范围
        5.2.1     右移0~31是可以的，假设int为32位
    5.3、有符号数和无符号数运算，有符号数转换为无符号数
6、内存位置0：感觉不太重要，基本上应该避免读取内存位置0
7、除法运算时发生截断
    7.1、这个自己在写程序的时候也会遇到，主要是一些范围方面的麻烦
    7.2、书上没有提出什么有效的解决方法
8、随机数大小
    8.1、有个宏定义了RAND_MAX，决定随机数的大小
9、大小写转换
    9.1、主要是说一些C语言的实现使用宏来实现，一些使用函数来实现
10、首先释放，然后重新分配
    10.1、讲的是一些挺怪异的指针使用
    10.2、建议指针释放后，就不要再尝试对其进行解释使用
11、可移植性问题的一个例子
    11.1、例子觉得不太好，不过有个挺有意思的表达式
    11.2、“0123456789”[n%10]，这个表达式的含义是n的个位数代表的字符

Big Endian: 最低地址存放高位字节，也叫高位优先。 PowerPC和SPARC处理器一般是高位优先。
Little Endian: 最低位地址存放低位字节，也叫低位优先。  Intel x86/x86_64都采用低位优先。

附带的作者访谈中对C++程序员的重要建议：

1. 避免使用指针
2. 提倡使用程序库
3. 使用类来表示概念

# 导航

[目录](README.md)

上一章：[预处理器.md](预处理器.md)

End.