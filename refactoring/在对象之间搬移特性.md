- [搬移函数 Move Method](#搬移函数movemethod)
- [搬移字段 Move Field](#搬移字段movefield)
- [提炼类 Extract Class](#提炼类extractclass)
- [将类内联化 Inline Class](#将类内联化inlineclass)
- [隐藏“委托关系” Hide Delegate](#隐藏委托关系hidedelegate)
- [移除中间人 Remove Middle Man](#移除中间人removemiddleman)
- [引入外加函数 Introduce Foreign Method](#引入外加函数introduceforeignmethod)
- [引入本地扩展 Introduce Local Extension](#引入本地扩展introducelocalextension)

# 搬移函数 Move Method
你的程序中，有个函数与其所驻类之外的另一个类有更多的交流，调用后者，或者被后者调用。那么，就在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数编程一个单纯的委托函数，或者是将旧函数完全移除。

做法：
* 检查源类中被源函数所使用的一切特性（字段和函数），考虑它们是否也应该被搬移
* 检查源类的子类和超类，看看是否有该函数的其他声明（如果有，可能无法搬移）
* 在目标类中声明这个函数（新的名称，对目标类更有意义）
* 将源函数的代码复制到目标函数中，调整后者，使得在新家中正常运行
* 编译目标类
* 决定如何从源函数正确引用目标对象
* 编译、测试
* 决定是否删除源函数，或把它当做一个委托函数留下来
* 如果要移除源函数，请将源类中对源函数的所有调用，都替换为对目标函数的调用
* 编译、测试

# 搬移字段 Move Field
你的程序中，某个字段被其驻类之外的另一个类更多的引用。在目标类建立一个字段，修改源字段的所有用户，令它们改用新字段。

做法：
* 如果字段的访问级是public，那就用Encapsulate Field封装起来（如果你有可能移动那些频繁访问该字段的函数，或如果有许多函数访问某个字段，先使用Self Encapsulate Field 也会有帮助）
* 编译、测试
* 在目标类中建立与源字段相同的字段，并同时建立相应的set/get
* 编译目标类
* 决定如何在源对象中引用目标对象
	1. 首先看是否有一个现成的字段或函数可以助你得到目标对象，如果没有，看能否建立这样一个函数。如果还是不行，就在源类中新建一个字段来存放目标对象。
* 删除源字段
* 将所有对源字段的引用替换为对某个目标函数的调用
	1. 如果源字段不是private的，就必须在源类的所有子类中查找源字段的引用点，替换
* 编译，测试

# 提炼类 Extract Class
某个类做了应该两个类做的事。建立一个新类，将相关的字段和函数搬移到新类中。
动机：单一职责原则！

做法：
* 决定如何分解类所负的责任
* 建立一个新类，用以表现从旧类中分离出的责任（注意新类和旧类的命名问题）
* 建立“从旧类访问新类”的连接关系（有可能是双向连接，在真正需要之前，不要建立“新类到旧类”的连接）
* 对于你想搬出的每一个字段，运用Move Field
* 每次搬移之后，编译、测试
* 使用Move Method将必要函数搬移到新类。先搬移较低层函数（也就是被调用次数多于调用次数的），再搬移较高层函数
* 每次搬移之后，编译、测试
* 检查，精简每一个类的接口（若是双向连接，可否单向）
* 决定是否公开新类

# 将类内联化 Inline Class
某个类没有做太多事情，将这个类的所有特性搬移到另一个类中，然后移除原类。
与Extract Class相反，如果一个类不再承担足够责任，就没有单独存在的理由。

做法：
* 在目标类上声明源类的public协议，将其中所有函数委托至源类
	1. 如果以一个独立接口标识源类函数更合适的话，就应该在内联之前先使用Extract Interface
* 修改所有源类的引用点，改为引用目标类
	1. 源类声明为private，以斩断包之外的所有引用可能。同时修改源类的名称，帮助捕捉隐藏的引用点
* 编译、测试
* 运用Move Method和Move Field，将源类的特性搬移到目标类
* 为源类举行一个简单的“丧礼”

# 隐藏“委托关系” Hide Delegate
客户通过一个委托类调用另一对象。在服务器上建立客户所需的所有函数，用以隐藏委托关系。（只是隐藏，中间人还在）
动机：封装，每个对象应该尽量少的了解系统的其他部分。

做法：
* 对于每个委托关系中的函数，在服务对象端建立一个简单的委托函数
* 调整客户，令它只调用服务对象提供的函数（如果使用者和服务提供者不在一个包，还要考虑委托函数的访问权限）
* 每次调整后，编译、测试
* 如果将来不再有客户调用受托类，考虑移除服务对象中的相关访问函数
* 编译、测试

# 移除中间人 Remove Middle Man
某个类做了过多的简单委托动作。让客户直接调用受托类。

做法：
* 建立一个函数，用以获得受托对象
* 对于每个委托对象，在服务类中删除该函数，并让需要调用该函数的客户转而调用受托对象
* 处理每个委托对象后，编译、测试

# 引入外加函数 Introduce Foreign Method
你需要为提供服务的类增加一个函数，但你无法修改整个类。在客户类中建立一个函数，并以第一参数形式传入一个服务器实例。
如果你为一个服务类建立大量的外加函数，就不该使用本项重构手段，考虑Introduce Local Extension。

做法：
* 在客户端建立一个函数，提供你需要的功能（这个函数不应该调用客户端的任何特性，如果它需要一个值，那就当做参数传递给它）
* 以服务类实例作为该函数的第一个参数
* 将该函数注释为“外加函数，应该在服务类实现”（如果有机会将外加函数添加到服务类中，你可以轻松找到它们）

# 引入本地扩展 Introduce Local Extension
你需要为服务类提供一些额外函数，当你无法修改这个类。建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包转类。
