# C++语言99个常见编程错误
#literature-note

[豆瓣](https://book.douban.com/subject/3767699/)

![cover](https://img9.doubanio.com/view/subject/l/public/s3927269.jpg)

- [C++语言99个常见编程错误](#c语言99个常见编程错误)
  - [1. 基础问题](#1-基础问题)
    - [过分积极的注释](#过分积极的注释)
    - [幻数 – 字面常量](#幻数字面常量)
    - [全局变量](#全局变量)
    - [未能区分函数重载和形参默认值](#未能区分函数重载和形参默认值)
    - [对引用的认识误区](#对引用的认识误区)
    - [对常量的认识误区](#对常量的认识误区)
    - [无视基础语言的精妙](#无视基础语言的精妙)
    - [未能区分可访问性和可见性](#未能区分可访问性和可见性)
    - [使用糟糕的语言](#使用糟糕的语言)
    - [无视习惯用法](#无视习惯用法)
    - [聪明反被聪明误](#聪明反被聪明误)
  - [2. 语法问题](#2-语法问题)
    - [数组定义和值初始化的语法形式混淆](#数组定义和值初始化的语法形式混淆)
    - [捉摸不定的评估求值顺序](#捉摸不定的评估求值顺序)
    - [运算符的优先级问题](#运算符的优先级问题)
    - [取大优先解析原则带来的问题](#取大优先解析原则带来的问题)
    - [声明修饰符次序的小聪明](#声明修饰符次序的小聪明)
    - [“函数还是对象”的多义性](#函数还是对象的多义性)
    - [效果漂移的类型量化饰词](#效果漂移的类型量化饰词)
    - [自反初始化](#自反初始化)
    - [静态连接类型和外部连接类型](#静态连接类型和外部连接类型)
    - [运算符函数名字查找的反常行为](#运算符函数名字查找的反常行为)
    - [晦涩难懂的operator->](#晦涩难懂的operator-)

## 1. 基础问题

### 过分积极的注释

[[Comment In Code]]

画蛇添足，最有效率的代码就是根本不存在的代码，最好的注释就是根本用不着注释。

> gugeng: 注释应该去做代码做不到的事情，作为代码的补充。代码既然说明了 what 和 how，注释应该去解释 why

如果某种结构（函数、类型的公开接口）能被塞到一页里，三四十行，它就容易理解。

> gugeng: 代码的坏味道 - 过长的函数，函数短的好处不仅在于可读性，更可能复合单一职责原则，更有可能是好的设计

一个声名狼藉的编码实践就是把更改日志作为注释插入到源文件的头部或尾部。

想不用注释，就要遵循简单易行的、定义良好的命名习惯。

> gugeng: 让代码去做好代码的事情

函数声明中形式参数的名字尤其重要。

减少注释的办法就是采用标准库中的、或尽人皆知的组件。

注释不应该维护显而易见的事儿，或把别的地方已经说清楚的东西再重复一遍。

> gugeng: 注释应该站在更高角度来看代码

### 幻数 – 字面常量

字面常量的主要问题是它们没有（抽象）语义。

在其所在作用域有着明确含义的枚举常量，不占空间，也没有任何运行期成本。

字面常量有一个坏处就是它会以意想不到的方式降低它所代表的类型那个的精度。

使用枚举常量或初始化了的具名常量代替幻数。

### 全局变量

全局变量阻碍了代码重用，增加了模块的耦合。

仅仅把对于值的访问加上函数形式的包装，就获得了可贵的可扩展性。

### 未能区分函数重载和形参默认值

函数重载和形参默认值的语法很类似，不要混淆，默认参数，就可以不写参数了。

重载用于一组抽象意义相同，但实现不同的函数。形参默认值处于简化，为函数提供更简洁的接口。

### 对引用的认识误区

引用只是其初始化物的别名，引用是没有地址的，甚至有可能不占任何存储。

所以，声明引用的引用，指向引用的指针，引用的数组，都是不合法的。

在引用类型前面加上const或volatile是可以的，但会忽略。

指向数组的引用保留了数组尺寸信息，而指针则不保留。

强制类型转换的结果是右值，而不是左值。

### 对常量的认识误区

字面常量没有地址，永远不可能改变其值。

如果把左值理解为“能放置值的地方”，右值就是没有与之相关的地址的值。

`const int *p2 = &ci`, const描述了通过p2对ci的操作的约束，而不是对于ci的一般操作的约束。

### 无视基础语言的精妙

```c++
int x = 1;
switch(x)
{
    default:cout<<"default" <<endl;
    case 0: cout<<0<<endl;break;
    case 2:cout<<2<<endl;
}
```
输出为default 0

在switch语句的任何地方都可以用case标记，而且不一定要在一个嵌套里。

```c++
switch(expr)
    default:
    if(cond1)
{
    case 1: stmt1;
    case 2: stmt2;
}
else
{
    if(cond2)
    case 3:stmt3;
    else
    case 0:;
}
```

例子

```c++
switch(1)
    default:
    if(0)
{
    case 1: cout << 1 << endl;
if(0)
    case 2: cout << 2 << endl;
}
else
{
    if(1)
    case 3: cout << 3 << endl;
    else
    case 0: cout << 0 << endl;;
}
```
输出为 1
`bool r = a < b; `来代替if语句

条件运算符来代替if else。

### 未能区分可访问性和可见性

C++语言压根儿就没有实现什么数据隐藏，它实现的是访问层级。在class中具有protected和private访问层级并非不可见，只是不可访问。

提供一个放置各种适当前置声明的专用头文件。

把class接口与实现分离，从而达到数据隐藏的效果，最好的办法是使用Bridge模式。

```c++
#include<iostream>
using namespace std;
class B
{
   public:
     void g(){ cout << "B::g()" << endl; }
   private:
     virtual void f() { cout << "B::f()" << endl; }
};
class D: public B
{
   public:
     void f(){ cout << "D::f()" << endl; }
   private:
     double g;
};
int main()
{
     D *d = new D();
     d->f();
     return 0;
}
```
输出为D::f()，如果B *b = new D(); 再调用b->f()是不可行的

### 使用糟糕的语言

NULL符号在不同的平台上，有多种定义的方法，可移植性差，真正领会了C++精神的程序员仍然使用0。

### 无视习惯用法

auto_ptr能够从堆上分配空间，当不可用时，自动善后。

当一个auto_ptr使用另一个auto_ptr对象初始化或赋值时，源对象就终止了对它只设的从堆上分配的对象的所有权。

### 聪明反被聪明误

a+++++b，错误，i++不是左值。

a+++ ++b 正确。

ptr->*m，正确。

ptr-> *m，错误。

遵循习惯用法，清晰的表达和一点点效率的损失好过小聪明、模棱两可和维护便利的丧失。

## 2. 语法问题

### 数组定义和值初始化的语法形式混淆

`int *ip = new int(12); ` ip指向的是单个的一个整数。
`int *ip = new int[12]; ` 正确的内存申请方法。

最好的内存申请形式就是根本不去申请，直接用标准库的组件：Vector或者其他。

### 捉摸不定的评估求值顺序

函数参数的求值没有固定的顺序，必须手动消除这样的副作用。

子表达式的求值次序也不一样，运算符的优先级和结合性对求值次序没有影响。

new会比类型的构造函数先调用，先为对象拿到存储，再在这个存储上初始化它。

逗号，三目运算符有求值顺序的。

逻辑运算符&&和||有短路特性，也算是有顺序么？YEP。

### 运算符的优先级问题

C++中，没有非结合的运算符。

`a>b>c`，合法，但可能词不达意。

### 取大优先解析原则带来的问题

词法分析引入取大优先解析原则：尽可能取长的字符序列作为词法单位。

a+++++b是非法的，它被解析为a++ ++ +b。

list<vector<string>> lovos也是错的，list<vector<string> 空格> lovos。

### 声明修饰符次序的小聪明

先写连接修饰词，再写量化修饰词，再写类型。
`extern const int size = 1024`。

指向常量的指针有两种声明形式：

1. `const int *pc;`
2. `int const *pc;`

### “函数还是对象”的多义性

对象的默认初始化语句不应该写成一个空的初始化参数列表的形式，因为它会被解释成一个函数声明。如String x()。

该多义性在new表达式中并不发作：String *p = new String()，可以。

### 效果漂移的类型量化饰词

内建数组不可能有const或volatile，所以修饰它的类型量化饰词（const或volatile）的效果实际上会漂移，转而应用到其持有物的某个适当位置，

量化饰词的实际效果会转移到数组的元素上去了。

### 自反初始化

```c++
int var = 1;
{
	double var = var; //编译通过，但行为未定义，右边用到的var正是刚刚声明的
}
const int var = 1;
{
enum{var = var};
}
```

这是可以的，枚举的声明位置，与变量不同，是在它的初始化对象（枚举的定义）之后的。后面一个var是外层作用域中的常量。

### 静态连接类型和外部连接类型

根本没有本条款名称所说的这种东西。

连接类型饰词总是绑定到对象或函数，而不是类型。

```c++
static class R
{} r; //静态的
R r2;//非静态的
```

匿名名字空间

```c++
namespace{
R r2;
R r;
}
```

这样，r和r2就有了外部连接类型，能有比用static修饰用在更多的地方，而且就像静态对象一样，它们在当前编译单元以外的地方不可访问。

### 运算符函数名字查找的反常行为

当我们记不住中序记法时，函数调用更清晰。

`a = b;`
`a.operator = (b)`

中序和函数调用的名字查找顺序不一样。

### 晦涩难懂的operator->

内建的operator->是二元的，重载版本的operator->是一元的。对于重载的operator->的调用，必须返回一个可以用（内建的）operator->访问其成员的。

operator->的调用序列的触发总是由包含operator->之定义的对象静态决定的，而且该调用顺序总是终结于返回指向class对象的内建指针的调用。
