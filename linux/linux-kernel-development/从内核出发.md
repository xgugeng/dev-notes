<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [2.1 获得内核源码](#21-%E8%8E%B7%E5%BE%97%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81)
  - [使用Git](#%E4%BD%BF%E7%94%A8git)
  - [安装内核源码](#%E5%AE%89%E8%A3%85%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81)
  - [使用补丁](#%E4%BD%BF%E7%94%A8%E8%A1%A5%E4%B8%81)
- [2.2 内核源码树](#22-%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E6%A0%91)
- [2.3 编译内核](#23-%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8)
  - [配置内核](#%E9%85%8D%E7%BD%AE%E5%86%85%E6%A0%B8)
  - [减少编译的垃圾信息](#%E5%87%8F%E5%B0%91%E7%BC%96%E8%AF%91%E7%9A%84%E5%9E%83%E5%9C%BE%E4%BF%A1%E6%81%AF)
  - [衍生多个编译作业](#%E8%A1%8D%E7%94%9F%E5%A4%9A%E4%B8%AA%E7%BC%96%E8%AF%91%E4%BD%9C%E4%B8%9A)
  - [安装新内核](#%E5%AE%89%E8%A3%85%E6%96%B0%E5%86%85%E6%A0%B8)
- [2.4 内核开发的特点](#24-%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E7%9A%84%E7%89%B9%E7%82%B9)
  - [无libc库或标准头文件](#%E6%97%A0libc%E5%BA%93%E6%88%96%E6%A0%87%E5%87%86%E5%A4%B4%E6%96%87%E4%BB%B6)
  - [GNU C](#gnu-c)
  - [没有内存保护机制](#%E6%B2%A1%E6%9C%89%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6)
  - [不要轻易在内核中使用浮点数](#%E4%B8%8D%E8%A6%81%E8%BD%BB%E6%98%93%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B5%AE%E7%82%B9%E6%95%B0)
  - [容积小而固定的栈](#%E5%AE%B9%E7%A7%AF%E5%B0%8F%E8%80%8C%E5%9B%BA%E5%AE%9A%E7%9A%84%E6%A0%88)
  - [同步和并发](#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%B9%B6%E5%8F%91)
  - [可移植性的重要性](#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 2.1 获得内核源码

登陆Linux官方网站（[http://www.kernel.org](http://www.kernel.org)）可以随时获得当前版本的Linux源码。

## 使用Git

```shell
git clone git://git.kernel.org/pub/scm/linux/kernel/git/torwalds/linux-2.6.git
```

## 安装内核源码

内核压缩以GNU zip（gzip）和bzip2两种形式发布。下载压缩包后，自行解压即可获得源码。

## 使用补丁

```shell
patch -p1 c ../patch-x.y.z
```

# 2.2 内核源码树

| 目录            | 描述                     |
| ------------- | ---------------------- |
| arch          | 特定体系结构的源码              |
| block         | 块设备I/O层                |
| crypto        | 加密API                  |
| Documentation | 内核源码文档                 |
| drivers       | 设备驱动程序                 |
| firmware      | 使用某些驱动程序而需要的设备固件       |
| fs            | VFS和各种文件系统             |
| include       | 内核头文件                  |
| init          | 内核引导和初始化               |
| ipc           | 进程间通信代码                |
| kernel        | 像调度程序这样的核心子系统          |
| lib           | 通用内核函数                 |
| mm            | 内存管理子系统和VM             |
| net           | 网络子系统                  |
| samples       | 示例代码                   |
| scripts       | 编译内核所用的脚本              |
| security      | Linux安全模块              |
| sound         | 语音子系统                  |
| usr           | 早期用户空间代码（所谓的initramfs） |
| tools         | 在Linux开发中有用的工具         |
| virt          | 虚拟化基础结构                |

# 2.3 编译内核

## 配置内核

配置选项既可以用来决定哪些文件编译进内核，也可以通过预处理命令来处理代码。

内核提供了不同的工具来简化内核配置，最简单的一种是一个命令行工具：

```shell
make config
```

该工具会逐一遍历所有的配置项，让用户选择yes、no或module。

另一个基于ncurse库编制的图形界面工具：

```shell
make menuconfig
```

或者，基于gtk+的图形工具：

```shell
make gconfig
```

一旦你配置好了内核，就可以编译它了：

```shell
make
```

## 减少编译的垃圾信息

如果你想尽可能少的看到垃圾信息，又不想错过错误报告和警告信息，可以用重定向：

```shell
make > ../detritus
```

## 衍生多个编译作业

`make`程序能把编译过程拆分为多个并行的作业：

```shell
make -jn
```

其中，n是要衍生出的作业数。

## 安装新内核

安装内核和体系结构以及启动引导工具息息相关。例如，在使用grub的x86系统上，要把`arch/i386/boot/bzImage`拷贝到`/boot`目录下，编辑`/etc/grub/grub.conf`文件，为新内核建立启动项。

模块的安装是自动的，也独立于体系结构：

```shell
make modules_install
```

# 2.4 内核开发的特点

- 内核编程时，既不能访问C库，也不能访问标准的C头文件。
- 内核编程时，必须使用GNU C。
- 内核编程时，缺乏像用户空间那样的内存保护机制。
- 内核编程时，难以执行浮点运算。
- 内核给每个进程只有一个很小的定长堆栈。
- 内核支持异步中断、抢占和SMP，因此必须时刻注意同步和并发。
- 要考虑可移植性的重要性。

## 无libc库或标准头文件

这是个先有鸡还是先有蛋的问题。其次的原因是速度和大小。对于内核来说，完整的C库，哪怕只是一个子集，也太大且太低效了。

大部分常用的C库函数在内核中都得到了实现了。

## GNU C

内核并不完全符合ANSI C标准。只要有可能，内核开发者总是用到gcc提供的许多语言的扩展部分。

内核开发者使用的C语言涵盖了ISO C99标准和GNU扩展特性：

1. 内联函数。C99和GNU均支持内联函数。

2. 内联汇编。gcc支持在C函数中嵌入汇编指令。

3. 分支声明。gcc会对条件分支进行优化，根据条件出现的概率。


## 没有内存保护机制

如果内核自己非法访问了内存，后果很难控制。内核中发生的内存错误会导致 opps。

内核中的内存都不分页，也就是说，你每用掉一个字节，物理字节就减少一个字节。

## 不要轻易在内核中使用浮点数

在用户空间的进程中执行浮点操作时，内核会完成从整数操作到浮点数操作的模式转换。执行浮点数指令时到底会做些什么，因体系结构不同，内核的选择也不同。

内核并不能完美地支持浮点操作，因为它本身不能陷入。内核中使用浮点数，除了要人工保存和恢复浮点寄存器，还有其他一些琐碎的事情要做。

## 容积小而固定的栈

内核栈的准确大小随体系结构而变。在x86上，栈的大小在编译时配置，可以是4KB或8KB。从历史上说，内核栈的大小是两页，也就意味着，32位机的内核栈是8KB，64位机的内核栈是16KB。

## 同步和并发

内核很容易产生竞争条件。内核的许多特性都要求能够并发地访问共享数据，这就要求有同步机制保证不出现竞争条件，特别是：

- Linux是抢占多任务操作系统。内核的进程调度程序即兴对进程进行调度，必须和这些任务同步。
- Linux内核支持对称多处理系统（SMP）。如果不加保护，两个处理器执行的内核代码可能会访问同一资源。
- 中断是异步的，有可能在代码访问资源的时候中断，这样中断处理程序就可能访问同一资源。
- Linux内核可以抢占。如果不加保护，可能会导致几段代码同时访问相同的资源。

## 可移植性的重要性

必须把与体系结构相关的代码从内核代码树的特定目录中适当地分离出来。

# 导航

[目录](README.md)

上一章：[1. Linux内核简介](Linux内核简介.md)

下一章：[3. 进程管理](进程管理.md)
