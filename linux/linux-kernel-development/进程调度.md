<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [4.1 多任务](#41-%E5%A4%9A%E4%BB%BB%E5%8A%A1)
- [4.2 Linux的进程调度](#42-linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6)
- [4.3 策略](#43-%E7%AD%96%E7%95%A5)
  - [4.3.1 I/O消耗型和CPU消耗型的进程](#431-io%E6%B6%88%E8%80%97%E5%9E%8B%E5%92%8Ccpu%E6%B6%88%E8%80%97%E5%9E%8B%E7%9A%84%E8%BF%9B%E7%A8%8B)
  - [4.3.2 进程优先级](#432-%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7)
  - [4.3.3 时间片](#433-%E6%97%B6%E9%97%B4%E7%89%87)
- [4.4 Linux调度算法](#44-linux%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)
  - [4.4.2 Unix系统中的进程调度](#442-unix%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6)
  - [4.4.3 公平调度](#443-%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6)
- [4.5 Linux调度的实现](#45-linux%E8%B0%83%E5%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0)
  - [时间记账](#%E6%97%B6%E9%97%B4%E8%AE%B0%E8%B4%A6)
  - [进程选择](#%E8%BF%9B%E7%A8%8B%E9%80%89%E6%8B%A9)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

调度程序负责决定哪个进程投入运行，何时运行以及运行多长时间。进程调度程序可以看做在可运行态进程之间分配有限的处理器时间资源的内核子系统。

最大限度利用处理器时间的原则是，只要有可以执行的进程，那么就总有进程正在执行。但只要系统中可运行进程的数目比处理器的个数多，就注定某一给定时刻会有一些进程不能执行。

# 4.1 多任务

多任务操作系统就是能同时并发地交互执行多个进程的操作系统。多任务操作系统都能使多个进程处于堵塞或者睡眠状态。这些任务尽管位于内存，但并不处于可运行状态。

多任务系统可以分为两类：

1. 非抢占式多任务。Linux提供了抢占式的多任务。当今众多现代操作系统都采用动态时间片计算的方式，引入了可配置的计算策略。Linux的调度本身并没有采用时间片来达到公平调度。
2. 抢占式多任务。除非进程自己主动停止运行，否则它会一直执行。进程主动挂起自己的操作叫让步（yielding）。

# 4.2 Linux的进程调度

Linux 2.5 引入了叫做`O(1)`的调度程序。2.6 之后，开发者为了提高对交互程序的调度性能引入了新的进程调度算法，其中最著名的是『反转楼梯最后期限调度算法（Rotating Staircase Deadline scheduler）』，最终取代了`O(1)`调度程序。它现在被称为『完全公平调度算法』，简称CFS。

# 4.3 策略

策略决定调度程序在什么时候让什么进程运行。

## 4.3.1 I/O消耗型和CPU消耗型的进程

进程可以分为：

1. I/O消耗型。进程的大部分时间用来提交或等待I/O请求。这样的进程常处于可运行状态，但运行短短一会儿，就会因为I/O请求阻塞。
2. CPU消耗型。进程把大部分时间用在执行代码上，除非被抢占，否则它们都在不停地运行。对于这类进程，调度策略往往是降低它们的调度频率，而延长其运行时间。

调度策略通常要在两个矛盾的目标之间寻找平衡：

- 响应时间短
- 吞吐率高

Unix的调度程序倾向于I/O消耗型进程，以提供更好的响应速度。Linux为了保证交互式应用和桌面系统的性能，缩短响应时间，更倾向于优先调度I/O消耗型进程，但也为忽略CPU消耗型进程。

## 4.3.2 进程优先级

 调度算法中最基本的一类是基于优先级的 调度，这是根据进程的价值和其对处理器事件的需求来对进程分级的想法。通常是优先级高的进程先运行，低的后运行，相同优先级的进程按轮转方式调度。

Linux采用了两种不同的优先级范围：

- nice值。范围是 -20到+19，默认为0。越大的nice值意味着更低的优先级。OS X中，进程的nice值代表分配给进程的时间片的绝对值；Linux中的nice值代表时间片的比例。
- 实时优先级，默认的变化范围是0到99。越高的实时优先级也就意味着进程的优先级越高。

任何实时进程的优先级都高于普通的进程，也就是说实时优先级和nice优先级互不相交。

## 4.3.3 时间片

时间片是一个数值，表明进程在被抢站前所能持续运行的时间。调度策略都必须规定一个默认的时间片，但I/O消耗型不需要更常的时间片，CPU消耗型希望越长越好。

任何长时间片都将导致系统交互表现变差，所以默认的时间片很短。Linux的CFS调度器并没有直接分配时间片到进程，而是将处理器的使用比例划分为进程。

多数系统中，一个进程是否立刻投入运行，完全由进程优先级和是否有时间片决定的。而Linux系统的抢占式的，抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，那么新进程立刻运行。

# 4.4 Linux调度算法

Linux调度器以模块方式提供的，这样的目的允许不同类型的进程可以针对性地选择调度算法。这种模块化结构成为调度器类（scheduler classes），允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的继承。每个调度器都有一个优先级。基础的调度器定义在`kernel/sched.c`文件中。它会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器胜出，去选择下面要执行的那一个程序。

完全公平调度（CFS）是一个针对普通进程的调度类，定义在`kernel/sched_fair.c`中。

## 4.4.2 Unix系统中的进程调度

Unix上，优先级以nice值形式输出给用户空间，这会带来很多问题：

第一个问题，若要将nice值映射到时间片，就必然需要将nice单位值对应到处理器的绝对时间。但这样将导致进程切换无法最优化进行。如果默认nice值（0）对应一个100ms的时间片，如果要两个低优先级的进程（5ms）同时运行，那么10ms内就会又一次进程切换的消耗。

第二个问题，涉及相对的nice值。两个进程，优先级是0和1，与18和19的情况下，获得的处理器时间大不一样。

第三个问题，如果执行nice值到时间片的映射，我们需要能分配一个绝对是时间片，这个时间片必须能够在内核的测试范围内。在多数操作系统中，这意味着时间片必然是定时器节拍的整数倍。这就限制了两个时间片的差异，时间片也会跟着定时器节拍变化。

第四个问题，为了让进程更快地运行，而去对新要唤醒的进程提升优先级，即便它们的时间片已经用尽了。这就打破了公平原则，损害了其它进程的利益。

## 4.4.3 公平调度

CFS完全摒弃了时间片，而是分配给进程一个处理器使用比重。CFS允许每个进程运行一段时间、循环轮转、选择运行最少的一个进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法了。

CFS 在所有可运行进程总数的基础上计算出一个进程应该运行多久，而不是靠nice值计算时间片。nice值在CFS中被作为进程获得的处理器运行比的权重：越高的nice值，意味着更低的处理器使用权重。

每个进程都按其权重在全部可运行进程中所占的比例的『时间片』来运行。为了避免切换的消耗，CFS为每个进程获得的时间片设定了最小粒度。

任何金成所获得的处理器时间是由自己和其他所有可运行进程nice值的相对差值决定的。nice值对时间片的作用不再是算术加权，而是几何加权。nice值对应的绝对时间不再是一个绝对值，而是处理器的使用比。

# 4.5 Linux调度的实现

CFS相关代码在`kernel/sched_fair.c`中，我们特别关注的四个部分：

- 时间记账
- 进程选择
- 调度器入口
- 睡眠和唤醒

## 时间记账

所有的调度器都必须对进程运行时间做记账。分配一个时间片给每一个进程，那么每次时钟节拍发生时，时间片就会减少一个节拍周期。当一个进程的时间片被减少到0时，它就会被另一个尚未减到0的时间片可运行进程抢占。

CFS不再有时间片的概念，但也必须维护每个进程运行的时间记账。CFS使用调度器结构实体（`<linux/sched.h>`中的`struct sched_entity`）来追踪进程运行记账。

```c
struct sched_entity {
	struct load_weight	load;		/* for load-balancing */
	struct rb_node		run_node;
	struct list_head	group_node;
	unsigned int		on_rq;

	u64			exec_start;
	u64			sum_exec_runtime;
	u64			vruntime;
	u64			prev_sum_exec_runtime;

	u64			nr_migrations;

/* 省略许多统计变量，只有在设置了宏 CONFIG_SCHEDSTATS 才启用这些变量 */
};
```

调度器实体结构作为一个名为`se`的成员变量，嵌入在进程描述符`struct task_struct`内。

`vruntime`变量存放进程的虚拟运行时间，它的计算时经过了所有可运行进程总数的标准化（或者说被加权的）。虚拟实践的单位是`ns`，与定时器节拍不再相关。CFS使用`vruntime`来记录一个程序到底运行了多长时间以及它还应该再运行多久。

定义在`kernel/sched_fair.c`中的`update_curr()`函数实现了记账功能：

```c
static void update_curr(struct cfs_rq *cfs_rq)
{
	struct sched_entity *curr = cfs_rq->curr;
	u64 now = rq_clock_task(rq_of(cfs_rq));
	u64 delta_exec;

	if (unlikely(!curr))
		return;

  	// 获得最后一次修改负载后，当前任务所占用的运行总时间
	delta_exec = now - curr->exec_start;
	if (unlikely((s64)delta_exec <= 0))
		return;

	curr->exec_start = now;

	schedstat_set(curr->statistics.exec_max,
		      max(delta_exec, curr->statistics.exec_max));

	curr->sum_exec_runtime += delta_exec;
	schedstat_add(cfs_rq->exec_clock, delta_exec);

	curr->vruntime += calc_delta_fair(delta_exec, curr);
	update_min_vruntime(cfs_rq);

	if (entity_is_task(curr)) {
		struct task_struct *curtask = task_of(curr);

		trace_sched_stat_runtime(curtask, delta_exec, curr->vruntime);
		cpuacct_charge(curtask, delta_exec);
		account_group_exec_runtime(curtask, delta_exec);
	}

	account_cfs_rq_runtime(cfs_rq, delta_exec);
}
```

`update_curr()`计算了当前进程的执行时间，放在变量`delta_exec`中，又将运行时间传递给了`__update_curr()`，后者再根据当前可运行进程总数对运行时间进行加权计算。最终将上述的权重值与当前运行进程的`vruntime`相加。

`update_curr()`是由系统定时器周期性调用的。`vruntime`可以准确测量给定进程的运行时间，且知道谁该是下一个被运行的进程。

## 进程选择

