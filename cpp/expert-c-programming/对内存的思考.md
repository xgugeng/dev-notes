<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [虚拟内存](#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)
- [Cache](#cache)
- [堆和数据段](#%E5%A0%86%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5)
- [内存泄漏](#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)
- [总线错误](#%E6%80%BB%E7%BA%BF%E9%94%99%E8%AF%AF)
- [段错误](#%E6%AE%B5%E9%94%99%E8%AF%AF)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

不同的段地址和偏移地址形成的指针可能指向同一个内存地址。

今天计算机系统结构的真正挑战不是内存的容量，而是内存的速度。

 

# 虚拟内存

虚拟内存 – 使用磁盘保存运行进程的映像，通过“页”的形式组织，页就是磁盘和内存之间来回移动的单位。

在磁盘上有个特殊的交换区，用来保存从内存中换出的进程。

进程只能操作位于物理内存中的页面。

 

# Cache

Cache的操作速度与系统的周期时间相同。

Cache包含一个地址的列表以及它们的内容，所有对内存的读取和写入都要经过cache。

Cache采用写直达，写回法，保持命中。

行Line是对Cache进行访问的单位，一个行内的数据称为块block。

 

# 堆和数据段

堆中的所有东西都是匿名的，不能按名字访问，只能通过指针。

堆内存的回收不必与所分配顺序一致，它甚至可以不回收。

管理内存的调用：malloc、free、brk和sbrk（调整数据段的大小）。

 

# 内存泄漏

堆经常出现两种类型的问题：

1. 释放和改写仍在使用的内存（内存损坏）。
2. 未释放不再使用的内存（内存泄漏）。

Tips：每次malloc后，调用free释放它。或者，尽可能地使用alloca来分配，它会被自动释放掉。

 

如何检测内存泄漏：

1. 使用swap查看还有多少可用的交换空间。
2. 确定可以的进程：如果一个进程不断增长却从不缩小。

 

# 总线错误

总线错误几乎都是由于未对齐的读和写引起的，而数据项是不能跨越页面或Cache边界的。

编译器通过自动分配和填充数据来进行对齐。

 

# 段错误

段错误是由于内存管理单元（负责支持虚拟内存的硬件）的异常所致。该异常是由于解除一个引用一个未初始化或者非法值的指针引起的。

导致段错误的直接原因：

1. 解除引用一个包含非法值的指针。
2. 解除引用一个空指针。
3. 在未得到授权时进行访问。
4. 用完了堆栈空间。

 

导致段错误的编程错误是：

1. 坏指针错误（free指针之后，再置为空）。
2. 改写错误（数组越界写入，改写一些堆管理数据结构）。
3. 指针释放引起的错误（两次释放，释放为分配的空间，释放仍在使用的空间，释放无效的指针）。



# 导航

[目录](README.md)

上一章：[6. 运行时数据结构](6. 运行时数据结构.md))

下一章：[8. 为什么程序员无法区分万圣节和圣诞节](8. 为什么程序员无法区分万圣节和圣诞节.md)