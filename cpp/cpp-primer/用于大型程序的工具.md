<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [异常处理](#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86)
- [命名空间](#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4)
- [多重继承与虚继承](#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 异常处理

当抛出一个表达式的时候，被抛出对象的静态编译时类型将决定异常对象的类型。如果抛出一个指向派生类对象的基类指针，该对象会被分割，只抛出基类部分。

抛出指向局部对象的指针几乎总是错误的。

栈展开：沿着嵌套函数调用链继续向上，直到为异常找到一个catch子句。

析构函数应该从不抛出异常。

 

查找匹配的处理代码：

1、允许非const到const转换

2、允许派生类到基类的转换

3、将数组转换为指向数组类型的指针，将函数转换为指向函数类型的适当指针

4、不允许标准算术转换，也不允许类类型定义的转换

catch对异常对象或引用的操作，就像函数调用一样。

如果catch想捕获因继承而相关的类型的异常，应该将自己的形参设为引用。

当catch形参是基类类型时，重新抛出的实际类型是异常对象的动态类型。

捕获所有异常的catch(…)

标准库的auto_ptr类是一个模版，为动态分配的对象提供异常安全。

 

# 命名空间

命名空间可以在全局作用域或其他作用域内部定义，但不能在函数或类内部定义。

命名空间可以在几个部分中定义，命名空间由它的分离定义部分的总和构成。

命名空间可以嵌套，遵循屏蔽原则。

命名空间可以是未命名的，namespace后面是花括号，命名空间局部于特定文件，从不跨越多个文件。

 

# 多重继承与虚继承

构造函数调用次序不受构造函数初始化列表中出现的基类的影响，也不受基类在构造函数初始化列表中的出现次序的影响。

多重继承下，派生类的指针或应用可以转换为其任意基类的指针或引用。

假定所有的根基类都是虚析构函数，则无论哪种指针类型删除对象，处理都是一致的。

多个基类可能导致二义性。

虚继承，虚基类是会有一个对象，也可以通过基类类型的指针或引用操作派生类的对象。

# 导航

[目录](README.md)

上一章：[16. 模版与泛型模版](16. 模版与泛型模版.md)

下一章：[18. 特殊工具与技术.md](18. 特殊工具与技术.md)
