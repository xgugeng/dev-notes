<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [模板定义](#%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89)
- [实例化](#%E5%AE%9E%E4%BE%8B%E5%8C%96)
- [模版编译模型](#%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9E%8B)
- [模版特化](#%E6%A8%A1%E7%89%88%E7%89%B9%E5%8C%96)
- [重载与函数模版](#%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 模板定义

函数模版

```c++
template<typename T> inline int compare(const T &v1, const T &v2)
{
	if(v1 < v2) return -1;

	if(v2 < v1) return 1;

	return 0;
}
```

类模版 `template<class Type> class Queue{};`

使用类模版 `Queue<int> qi;`

模版形参的作用域：在声明为模版形参之后直到模版声明或定义的末尾处。

模版形参遵循常规名字屏蔽规则。

用作模版形参的名字不能在模版内部重用。

同一模版的声明和定义中，模版形参的名字不必相同。

模版类型形参前面必须带上关键字class或typename（相同涵义），非类型形参前面必须带上类型名字，省略关键字或类型说明符是错的。

 

# 实例化

模版在使用时进行实例化。类模版在引用实际模版类类型时实例化，函数模版在调用它或用它对函数指针进行初始化或赋值时实例化。

类模版的每次实例化都会产生一个独立的类类型。为int实例化的Queue与任意其他Queue类型没有关系，也没有访问权。。

类模版的形参是必须的。

多个类型形参的实参必须完全匹配。

可以使用函数模版对函数指针进行初始化和赋值。

 

# 模版编译模型

包含编译模型 – 编译器必须看到用到的所有模版的定义。通过在声明函数模版或类模版的头文件中添加一条#include指示使定义可用。

分别编译模型 – 编译器会为我们跟踪相关的模版定义，但我们必须让编译器知道要记住给定的模版定义。可以使用export关键字。

export指明给定的定义可能会需要在其他文件中产生实例化。

 

# 模版特化

这部分没看，暂时掠过

 

# 重载与函数模版

函数模版可以重载。

当重载函数中，既有普通函数，又有模版函数，确定函数调用的步骤如下：

1. 为这个函数名建立候选集合，包括

   a) 与被调函数名字相同的任意普通函数

   b) 任意函数模版实例化，在其中，模版实参推断发现了与调用中所用函数实参匹配的模版实参

2. 确定哪些普通函数是可行的，候选集合中的每个模版实例都是可行的，因为有模版实参推断

3. 如果需要转换来进行调用，根据转换的种类排列可行函数

   a) 如果只有一个函数可选，则调用之

   b) 如果调用有二义性，从可行函数中去掉所有函数模版实例

4. 重新排列函数模版中的可行函数

   a) 如果只有一个函数可选，就调用

   b) 否则，二义性


# 导航

[目录](README.md)

上一章：[15. 面向对象编程](15. 面向对象编程.md)

下一章：[17. 用于大型程序的工具](17. 用于大型程序的工具.md)

