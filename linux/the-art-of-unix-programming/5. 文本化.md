<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [5.1 文本化的重要性](#51%C2%A0%E6%96%87%E6%9C%AC%E5%8C%96%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7)
- [5.2 数据文件元格式](#52%C2%A0%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%85%83%E6%A0%BC%E5%BC%8F)
- [5.3 应用协议设计](#53%C2%A0%E5%BA%94%E7%94%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1)
- [5.4 应用协议元格式](#54%C2%A0%E5%BA%94%E7%94%A8%E5%8D%8F%E8%AE%AE%E5%85%83%E6%A0%BC%E5%BC%8F)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

本章重在分析两种不同却又紧密联系的设计：设计将应用数据存储在永久存储器中的文件格式，和在协作程序中传递数据和命令的应用协议。两者都与内存数据结构的序列化有关。

对于计算机程序的内部操作而言，一个复杂数据结构最简便的表达就是所有字段都用机器自带的数据格式，所有指针都是实际地址。但这种表示法不利于数据的存储和传输。

# 5.1 文本化的重要性

文本流是非常有用的通用格式，是透明的。文本流的限制帮助了强化封装：文本里不鼓励复杂表达，也不提倡程序相互干涉内部状态。

使用二进制协议的唯一正当理由是：如果要处理大批量的数据集，因而确实关注能否在介质上获得更大位密度，或者非常关心将数据转化为芯片核心结构所必需的时间和指令开销。比如大图像和多媒体数据、对延时有严格要求的网络协议。

# 5.2 数据文件元格式

数据文件元格式是一套句法和词法约定。

以下是一些可作为典范使用的标准格式：
- DSV风格 分隔符分隔值，类似CSV之于Windows。注意字段中恰好有分隔符的情况。  
- RFC 822格式 源自互联网电子邮件信息采用的文本格式。记录属性每行存放一个，该行的其余部分都是属性值。  
- Cookie-Jar格式 为随机数据库使用的一种格式，适用于记录只是一堆非结构化文本的情况。这种格式使用跟随%%新行符作为记录分隔符。  
- Record-Jar格式 cookie-jar记录分隔符与RFC 822记录元格式的结合。  
- XML 尖括号括起的钱和&印号引导的字面值序列。适合复杂数据格式，无需知道数据语义，但是不能与Unix工具很好的配合。  
- Windows INI格式 即.ini文件。  
    
Unix文本格式的约定：

1. 以新行符结束的每一行只存一个记录  
2. 每行不超过80个字符  
3. 使用#引入注释  
4. 支持反斜杠约定  
5. 在每行一条记录的格式中，使用冒号或连续的空白作为字段分隔符  
6. 不要过分区分tab和空格  
7. 优先选用16进制而不是8进制  
8. 对于复杂的记录，使用“节（stanza）”格式：一个记录若有多行，就使用%%\n或%\n作为记录分隔符  
9. 在节格式中，要么每行一个记录字段，要么让记录字段和RFC 822电邮开头类似，用冒号终止的字段名关键字作为引导字段  
10. 要么包含一个版本号，要么将格式设计成相互独立的自描述字节块  
11. 注意浮点数取整问题  
12. 不要仅对文件的一部分进行压缩或二进制编码  

# 5.3 应用协议设计

如果应用协议是文本的，仅凭肉眼就可以分析。事务转存也容易解释，测试负载也容易编写。

应用协议的实例：SMTP、POP3、IMAP

# 5.4 应用协议元格式

经典的互联网应用元协议是文本格式，使用单行请求和响应，但有效数据载荷可以多行。

HTTP、BEEP、XML-RPC、SOAP和Jabber

# 导航

[目录](README.md)

上一章：[4. 模块性](4. 模块性.md)

下一章：[6. 透明性](6. 透明性.md)
