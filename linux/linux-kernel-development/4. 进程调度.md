调度程序负责决定哪个进程投入运行，何时运行以及运行多长时间。进程调度程序可以看做在可运行态进程之间分配有限的处理器时间资源的内核子系统。

最大限度利用处理器时间的原则是，只要有可以执行的进程，那么就总有进程正在执行。但只要系统中可运行进程的数目比处理器的个数多，就注定某一给定时刻会有一些进程不能执行。

# 4.1 多任务

多任务操作系统就是能同时并发地交互执行多个进程的操作系统。多任务操作系统都能使多个进程处于堵塞或者睡眠状态。这些任务尽管位于内存，但并不处于可运行状态。

多任务系统可以分为两类：

1. 非抢占式多任务。Linux提供了抢占式的多任务。当今众多现代操作系统都采用动态时间片计算的方式，引入了可配置的计算策略。Linux的调度本身并没有采用时间片来达到公平调度。
2. 抢占式多任务。除非进程自己主动停止运行，否则它会一直执行。进程主动挂起自己的操作叫让步（yielding）。

# 4.2 Linux的进程调度

Linux 2.5 引入了叫做`O(1)`的调度程序。2.6 之后，开发者为了提高对交互程序的调度性能引入了新的进程调度算法，其中最著名的是『反转楼梯最后期限调度算法（Rotating Staircase Deadline scheduler）』，最终取代了`O(1)`调度程序。它现在被称为『完全公平调度算法』，简称CFS。

# 4.3 策略

策略决定调度程序在什么时候让什么进程运行。

## 4.3.1 I/O消耗型和CPU消耗型的进程

进程可以分为：

1. I/O消耗型。进程的大部分时间用来提交或等待I/O请求。这样的进程常处于可运行状态，但运行短短一会儿，就会因为I/O请求阻塞。
2. CPU消耗型。进程把大部分时间用在执行代码上，除非被抢占，否则它们都在不停地运行。对于这类进程，调度策略往往是降低它们的调度频率，而延长其运行时间。

调度策略通常要在两个矛盾的目标之间寻找平衡：

- 响应时间短
- 吞吐率高

Unix的调度程序倾向于I/O消耗型进程，以提供更好的响应速度。Linux为了保证交互式应用和桌面系统的性能，缩短响应时间，更倾向于优先调度I/O消耗型进程，但也为忽略CPU消耗型进程。

## 4.3.2 进程优先级

 调度算法中最基本的一类是基于优先级的 调度，这是根据进程的价值和其对处理器事件的需求来对进程分级的想法。通常是优先级高的进程先运行，低的后运行，相同优先级的进程按轮转方式调度。

Linux采用了两种不同的优先级范围：

- nice值。范围是 -20到+19，默认为0。越大的nice值意味着更低的优先级。OS X中，进程的nice值代表分配给进程的时间片的绝对值；Linux中的nice值代表时间片的比例。
- 实时优先级，默认的变化范围是0到99。越高的实时优先级也就意味着进程的优先级越高。

任何实时进程的优先级都高于普通的进程，也就是说实时优先级和nice优先级互不相交。

## 4.3.3 时间片

时间片是一个数值，表明进程在被抢站前所能持续运行的时间。调度策略都必须规定一个默认的时间片，但I/O消耗型不需要更常的时间片，CPU消耗型希望越长越好。

任何长时间片都将导致系统交互表现变差，所以默认的时间片很短。Linux的CFS调度器并没有直接分配时间片到进程，而是将处理器的使用比例划分为进程。

多数系统中，一个进程是否立刻投入运行，完全由进程优先级和是否有时间片决定的。而Linux系统的抢占式的，抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，那么新进程立刻运行。

# 4.4 Linux调度算法

Linux调度器以模块方式提供的，这样的目的允许不同类型的进程可以针对性地选择调度算法。这种模块化结构成为调度器类（scheduler classes），允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的继承。每个调度器都有一个优先级。基础的调度器定义在`kernel/sched.c`文件中。它会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器胜出，去选择下面要执行的那一个程序。

完全公平调度（CFS）是一个针对普通进程的调度类，定义在`kernel/sched_fair.c`中。

## 4.4.2 Unix系统中的进程调度

Unix上，优先级以nice值形式输出给用户空间，这会带来很多问题：

第一个问题，若要将nice值映射到时间片，就必然需要将nice单位值对应到处理器的绝对时间。但这样将导致进程切换无法最优化进行。如果默认nice值（0）对应一个100ms的时间片，如果要两个低优先级的进程（5ms）同时运行，那么10ms内就会又一次进程切换的消耗。

第二个问题，涉及相对的nice值。两个进程，优先级是0和1，与18和19的情况下，获得的处理器时间大不一样。

第三个问题，如果执行nice值到时间片的映射，我们需要能分配一个绝对是时间片，这个时间片必须能够在内核的测试范围内。在多数操作系统中，这意味着时间片必然是定时器节拍的整数倍。这就限制了两个时间片的差异，时间片也会跟着定时器节拍变化。

第四个问题，为了让进程更快地运行，而去对新要唤醒的进程提升优先级，即便它们的时间片已经用尽了。这就打破了公平原则，损害了其它进程的利益。

## 4.4.3 公平调度

CFS完全摒弃了时间片，而是分配给进程一个处理器使用比重。CFS允许每个进程运行一段时间、循环轮转、选择运行最少的一个进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法了。

CFS 在所有可运行进程总数的基础上计算出一个进程应该运行多久，而不是靠nice值计算时间片。nice值在CFS中被作为进程获得的处理器运行比的权重：越高的nice值，意味着更低的处理器使用权重。

每个进程都按其权重在全部可运行进程中所占的比例的『时间片』来运行。为了避免切换的消耗，CFS为每个进程获得的时间片设定了最小粒度。

任何金成所获得的处理器时间是由自己和其他所有可运行进程nice值的相对差值决定的。nice值对时间片的作用不再是算术加权，而是几何加权。nice值对应的绝对时间不再是一个绝对值，而是处理器的使用比。

# 4.5 Linux调度的实现

