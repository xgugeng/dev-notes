<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [1.4 Unix之失](#14%C2%A0unix%E4%B9%8B%E5%A4%B1)
- [1.5 Unix之得](#15%C2%A0unix%E4%B9%8B%E5%BE%97)
- [1.6 Unix哲学基础](#16%C2%A0unix%E5%93%B2%E5%AD%A6%E5%9F%BA%E7%A1%80)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

没有一种操作系统能像Unix那样，能同时在作为研究工具、定制技术应用的友好宿主机、商用成品软件平台和互联网技术的重要部分等各个领域都大放异彩。

Unix与C语言相辅相成，缺一不可。

# 1.4 Unix之失

Unix文件在字节层次上毫无结构可言。文件删除了就没法恢复。Unix的安全模型太过原始，作业控制有待精致，命名方式非常混乱。

Unix最持久的哲学就是：行为的最终逻辑被尽可能地推后到**使用端**。最终用户永远比操作系统设计人员更清楚他们需要什么。

Unix只提供机制，而不是策略。策略相对短命，而机制会长存。

# 1.5 Unix之得

1、开源软件

2、跨平台可移植性和开放标准：从嵌入式到桌面机、从移动设备到服务器

3、Internet和万维网

4、开源社区

5、从头到脚的灵活性

6、Unix Hack之趣

7、Unix的经验别处也可适用

# 1.6 Unix哲学基础

Unix哲学是**自下而上的**，注重实效，立足于丰富的经验。

Unix管道的发明人Doug McIlroy曾说过：

1. 让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。
2. 假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。避免使用严格的分栏格式和二进制格式输入。不要坚持交互式输入。
3. 尽可能地早将设计和编译的软件投入使用。对拙劣的代码，别犹豫，直接扔掉。
4. 优先使用工具而不是拙劣的帮助文档来减轻编程任务的负担。

总结起来就是：一个程序之做好一件事，程序要能协作。程序要能处理文本流，因为这是最通用的接口。



Bob Pike的Unix哲学：

1. 发现程序的瓶颈，否则不要胡乱修改
2. 估量
3. 花哨的算法在n很小时通常很慢，而n通常很小
4. 花哨的算法比简单的算法更容易出bug，更难实现。优先使用简单的算法配合简单的数据结构
5. 数据压倒一切，编程的核心是数据结构而不是算法



整体上而言，Unix哲学可以概括为：

- 模块原则：使用简洁的接口拼接简单的部件
- 清晰原则：清晰胜于机巧，代码注释、考虑可扩展性、不盲目优化。
- 组合原则：这个基于模块原则，设计是考虑组合，最小立异性为中心。在输入输出方面，Unix极力提倡采用简单、文本化、面向流、设备无关的格式。在经典的Unix下，多数程序都采用简单过滤器的形式，即将一个输入的简单文本处理为一个简单的文本流输出。这增强了封装性，易于衔接。
- 分离原则：这个对组合原则聚合问题做出解耦思想，策略同机制分离，接口与引擎分离。
- 简洁原则：设计要简洁，尽可能降低复杂度。
- 吝啬原则：就是避免过度设计，编写大系统。
- 透明性原则：设计要可见。以便审查和调试。
- 健壮原则：源于透明与简洁。
- 表示原则：把知识叠入数据以求逻辑质朴而健壮（就是把它，程序化是它让程序员易懂，归结于健壮原则）。
- 通俗原则：接口设计避免标新立异（标准化，减少学习成本）。
- 缄默原则：一个程序没有什么好说，就保持缄默（我认为是看好的东西，让自己的意见说出来）。
- 补救原则：遇到暂时无法修复的时候就让它先退出终止。用第二种状态表示。
- 经济原则：宁花机械一分，不花程序员一秒（让程序做重复的事情）。
- 生成原则：避免手动hack，尽量编写程序生成（经济原则的实践版）。
- 优化原则：别过早优化，要先了解原型基础，收集数据，再下手。不要只求快。
- 多样原则：决不相信，不二大门（办法总比问题多，不要孤立，要聆听，沟通）。
- 扩展原则：这个基于多样性，则重考虑日后扩展，记着重构不是重写，它需要在，原有基础上优化，让它更加透明，简洁。

总结：Unix是这个由简单清晰模块组成的系统，它能够让人容易扩展，使用使用方便，能够让人喜悦（但事实配置让人操心）



Unix哲学一言以蔽之：Keep it simple, stupid!

- 只要可行，一切都应该做成与来源和目标无关的过滤器。
- 数据流应尽可能文本化（这样可以使用标准工具来查看和过滤）。
- 数据库部署和应用协议应尽可能文本化（让人可以阅读和编辑）。
- 复杂的前端（用户界面）和后端应该泾渭分明。
- 如果可能，用C编写前，先用解释性语言搭建原型。
- 当且仅当只用一门语言编程会提高程序复杂度时，混用语言编程才比单一语言编程来得好。
- 宽收严发（对接收的东西要包容，对输出的东西要严格）。
- 过滤时，不需要丢弃的信息决不丢。
- 小就是美。在确保完成任务的基础上，程序功能尽可能少。

要良好的运用Unix哲学，你就应该不断追求卓越。你必须相信，软件设计是一门技艺，值得你付出所有的智慧、创造力和激情。否则，你的视线就不会超越那些简单、老套的设计和实现；你就会在应该思考的时候急急忙忙跑去编程。你就会在该无情删繁就简的时候反而把问题复杂化——然后你还会反过来奇怪你的代码怎么会那么臃肿、那么难以调试。

要良好地运用Unix哲学，你应该珍惜你的时间决不浪费。一旦某人已经解决了某个问题，就直接拿来利用，不要让骄傲或偏见拽住你又去重做一遍。永远不要蛮干；要多用巧劲，省下力气到需要的时候再用，好钢用在刀刃上。善用工具，尽可能将一切都自动化。

# 导航

[目录](README.md)

下一章：[2. 历史-双流记](2. 历史-双流记.md)
