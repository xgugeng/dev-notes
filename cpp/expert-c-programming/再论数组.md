<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [什么时候数组和指针是相同的](#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

数组的声明就是数组，指针的声明就是指针。但在使用过程中，数组总是可以写成指针的形式，两者可以互换。

`extern char a[]`，不可以改写成指针的形式。

`char a[10]`，定义，不能改写成指针的形式。


# 什么时候数组和指针是相同的

1. 表达式中的数组名（与声明不同）被编译器当作一个指向高数组第一个元素的指针。
2. 下标总是与指针的偏移量相同。
3. 在函数声明中，数组名被编译器当作一个指向高数组第一个元素的指针。

1和2的理解就是对数组下标的引用总是可以写成“一个指向数组的起始地址的指针加上偏移量"。

```c++
int a[10], *p, i = 2;
p = a; p[i];
p = a; *(p+i);
p = a + i; *p; //三个等效
```

在表达式中，指针和数组是可以互换的，因为它们在编译器里的最终形式都是指针，都可以进行取下标操作。

指针是有类型限制的，为了算术运算。

使用指针比数组更有效率？谬误！

数组下标是定义在指针的基础上的，优化器常常把它转换为指针，并生成机器指令。这样做的根本原因不是指针比数组快，而是指针和偏移量才是底层硬件所使用的基本类型。

“类型的数组”的形参的声明应该调整 为“类型的指针”，编译器向函数传递数组的地址，而不是拷贝。

把数组形参当作指针，是出于效率的考虑。

函数的返回值绝对不能是一个函数数组，只能是函数的指针。

# 导航

[目录](README.md)

上一章：[8. 为什么程序员无法区分万圣节和圣诞节](8. 为什么程序员无法区分万圣节和圣诞节.md))

下一章：[10. 再论指针](10. 再论指针.md)