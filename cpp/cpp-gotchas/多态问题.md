<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [类型特征码](#%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81%E7%A0%81)
- [将基类析构函数声明为非虚函数](#%E5%B0%86%E5%9F%BA%E7%B1%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%BA%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0)
- [对非虚（成员）函数的遮掩](#%E5%AF%B9%E9%9D%9E%E8%99%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E9%81%AE%E6%8E%A9)
- [过分灵活的模版模式](#%E8%BF%87%E5%88%86%E7%81%B5%E6%B4%BB%E7%9A%84%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F)
- [重载虚函数](#%E9%87%8D%E8%BD%BD%E8%99%9A%E5%87%BD%E6%95%B0)
- [为参数指定默认和初始化物的虚函数](#%E4%B8%BA%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%89%A9%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0)
- [在构造函数和析构函数中调用虚函数](#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0)
- [虚赋值](#%E8%99%9A%E8%B5%8B%E5%80%BC)
- [未能区分函数的重载、改写和遮掩](#%E6%9C%AA%E8%83%BD%E5%8C%BA%E5%88%86%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%E6%94%B9%E5%86%99%E5%92%8C%E9%81%AE%E6%8E%A9)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 类型特征码

在面向对象思想中，对象的类型由其行为决定，而非由其状态决定。以数据成员的方式表示类型特征码，多此一举。

对象的类型一经初始化，便矢志不渝。

不要以数据成员的形式存储特征码，要使用虚函数代替它。

 

# 将基类析构函数声明为非虚函数

如果基类类型未将析构函数声明为虚函数，那么经由基类接口来析构派生类对象现在将带来未定义的恶果。

```c++
class Base
{
    Resource *br;
    ~Base(){delete br;}
};

class Derived:public Base
{
    OtherResource *dr;
    ~Derived(){delete dr;}
}

Base *bp = new Base;
delete bp; //没事

bp = new Derived;
delete bp; //灾难！
```
 

# 对非虚（成员）函数的遮掩

非虚（成员）函数指定了以基类为根的继承谱系中的不变量。

虚函数和纯虚函数就是指定（成员函数之行为）实现依类型之可变性的机制。

装饰器模式。

 

# 过分灵活的模版模式

模版模式将算法分离成不变部分和可变部分。

 

# 重载虚函数

避免重载虚函数并不会将基类接口带来的任何剧烈的约束。

 

# 为参数指定默认和初始化物的虚函数

避免在虚函数中提供参数默认初始化物。

 

# 在构造函数和析构函数中调用虚函数

为基类子对象截取或清算资源的代码就应该放在（基类类型的）构造函数和析构函数里，不要企图让基类代理派生类的资源管理之责。

 

# 虚赋值

赋值运算符声明为虚函数是合法的，但是虚赋值却鲜有其合理之处。

派生类类型中即使写了复制赋值运算符，也并不是对基类类型中的复制赋值运算符的改写。

通常，虚复制构造比虚赋值更好的设计思路，虚构造函数，也被称之为原型模式。

 

# 未能区分函数的重载、改写和遮掩

重载，不同的函数使用同一标识符，并且这些函数位于同一作用域。

派生类类型中的process函数声明在派生类作用域中，而并非基类作用域中，因此它不和基类中的函数形成重载关系。



# 导航

[目录](README.md)

上一章：[6. 内存和资源管理问题](6. 内存和资源管理问题.md)

下一章：[8. 类型设计问题](8. 类型设计问题.md)