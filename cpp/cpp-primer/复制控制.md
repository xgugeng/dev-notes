<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [复制构造函数](#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0)
- [赋值操作符](#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6)
- [析构函数](#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0)
- [管理指针成员](#%E7%AE%A1%E7%90%86%E6%8C%87%E9%92%88%E6%88%90%E5%91%98)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

不管类是否定义了自己的析构函数，编译器都自动执行类中非static数据成员的析构函数。

复制构造函数、赋值操作符、析构函数总称为复制控制，编译器自动实现这些操作。

 

# 复制构造函数

复制初始化首先使用指定的构造函数创建一个临时对象，然后用复制构造函数将其复制到正在创建的对象。

为了防止复制，必须显式声明其构造函数为private。

P.S. 声明而不定义成员函数是合法的。

不允许复制的类对象只能作为引用传递给函数或从函数返回，也不能用作容器。因为这三种情况，都用到了复制构造函数。

 

# 赋值操作符

Sales_item& operator=(const Sales_item &)

复制和赋值常一起使用。

 

# 析构函数

变量在超出作用域时自动撤销，动态分配的对象只有在指向它的指针被删除时才撤销。当对象的引用或指针超出作用域时，不会析构。撤销一个容器，也会析构，逆序撤销。

如果需要析构函数，那么也需要三个复制控制成员。

 

# 管理指针成员

复制指针时只复制指针中的地址，不会复制指针指向的对象。

C++采用以下方法管理指针：

1、常规指针型行为

2、智能指针

3、值型行为，指针指向的对象都是唯一的，由每个类独立管理。

智能指针：定义智能指针的通用技术是采用一个使用计数（use count），智能指针类将一个计数器与类指向的对象相关联。

# 导航

[目录](README.md)

上一章：[12. 类](12. 类.md)

下一章：[14. 重载操作符与转换](14. 重载操作符与转换.md)
