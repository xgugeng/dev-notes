# 类的定义和声明

简单说来，类就是定义了一个新类型和新的作用域。

在类内部定义的函数默认为inline，inline成员函数的定义必须在调用该函数的每个源文件中可见，不在类定义体内定义的inline成员函数，其定义通常放在有类定义的统一头文件中。

成员函数有个附加的隐含形参，将函数绑定到调用函数的对象，即this。

数据抽象是一种依赖于接口和实现分离的编程技术，封装是将低层次的元素组合起来形成新的、高层次实体的技术。

访问标号实现抽象和封装，一个标号出现的次数是没有限制的。

要确定“用户”是谁，代码用户？还是终端用户？

抽象和封装提供了两个重要优点：

1、 避免类内部出现无意的、可能破坏对象状态的用户级错误。

2、 可以根据需求或bug完善类实现，而不必改变用户代码。

成员函数可以重载，但只能重载本类的其他成员函数。

如果多个文件定义一个类，那么每个文件中的定义必须是完全相同的。

类不能具有自身类型的数据成员，但是可以有指向自身类型的指针和引用。

类的定义以分号结束。

 

# 隐含的this

不能从const成员函数返回指向类对象的普通引用，只能返回*this作为一个const引用。

基于成员函数是否为const，也可以重载，基于一个指针形参是否指向const，也可以重载。

可变数据成员：mutable，永远不能为const，甚至它是const对象的成员也如此。

 

# 类作用域

形参表和函数体处于类作用域中，可以不限定而引用其他成员。

函数返回类型不一定在类作用域中。

Screen::index Screen::get_cursot() const{return cursor}

类作用域的名字查找：

(1) 在使用该名字的块中查找名字的声明。只考虑在使用前声明的名字。

(2) 如果找不到，则在包围的作用域中查找。

一旦一个名字被用作类型名，它就不能重复定义。

 

# 构造函数

构造函数不能为const。

构造函数的初始化式只在构造函数定义中而不是声明中指定。

不管成员是否在构造函数初始化列表内显式初始化，类类型的数据成员总是在初始化阶段初始化。初始化发生在计算阶段之前。

采用初始化列表，或者在构造器内赋值。

如果没有为类成员提供初始化式，编译器会隐式使用默认构造函数，如果没有默认构造函数，则调用失败，这种情况下，必须提供初始化式。

没有默认构造函数的类类型的成员，以及const或引用类型的成员，不管哪种类型，必须在构造函数初始化列表中初始化。

定义成员的次序就是它们被初始化的顺序，而不是初始化列表中的顺序。

初始化式可以使任意表达式。

只要定义一个对象时没有提供初始化式，就使用默认构造函数。为所有形参提供默认实参的构造函数也定义了默认构造函数。

一个类哪怕只定义了一个构造函数，编译器也不会生成默认构造函数。

如果类包含了内置或复合的成员，则应该定义自己的构造函数来初始化这些成员。

由单个实参来调用的构造函数定义了从形参类型到该类类型的隐式转换，将构造函数声明为explicit，来防止需要在需要隐式转换的上下文中使用构造函数。

 

# 友元

友元机制允许一个类对其非公有成员的访问权授予指定的函数或成员。

必须先定义包含成员函数的类，才能将成员函数设为友元。

必须将重载函数集中每一个希望设为友元的函数都声明为友元。

 

# static

static相比于全局对象的优点：

1、 static的名字在类作用域，避免冲突。

2、 封装，static为私有，全局对象不可以。

3、 易读性。

static函数没有this指针

static成员不是通过类构造器进行初始化，而是在定义时进行初始化。

# 导航

[目录](README.md)

上一章：[11. 泛型算法](11. 泛型算法.md)

下一章：[13. 复制控制](13. 复制控制.md)
