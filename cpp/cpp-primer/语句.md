<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [简单语句](#%E7%AE%80%E5%8D%95%E8%AF%AD%E5%8F%A5)
- [声明语句](#%E5%A3%B0%E6%98%8E%E8%AF%AD%E5%8F%A5)
- [复合语句（块）](#%E5%A4%8D%E5%90%88%E8%AF%AD%E5%8F%A5%E5%9D%97)
- [语句作用域](#%E8%AF%AD%E5%8F%A5%E4%BD%9C%E7%94%A8%E5%9F%9F)
- [if](#if)
- [switch](#switch)
- [while](#while)
- [for](#for)
- [do while](#do%C2%A0while)
- [break](#break)
- [continue](#continue)
- [goto](#goto)
- [try和异常处理](#try%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86)
- [使用预处理器进行调试](#%E4%BD%BF%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 简单语句

空语句常见于循环中，同时，无关的空语句总是无害的。

# 声明语句

搞清定义和声明的区别。 

# 复合语句（块）

块标识了一个作用域，一个名字只能从其定义处到该块的结尾这段范围可见。 

# 语句作用域

更旧式的C++允许在`for`语句作用域之外访问控制变量。 

# if

`else`会匹配给最后出现的尚未匹配的`if`子句。 

# switch

如果`switch`中表达式与其中一个`case`的值匹配。则执行该标号后面的第一个语句开始依次执行每个语句，直到`switch`结束或遇到`break`。如果没有发现匹配的`case`标号（并且也没有`default`），则程序从`switch`语句后面的第一条语句继续执行。

有个普遍的误解是以为程序只会执行匹配的`case`标号相关联的语句，实际上，程序从该点开始，并跨越case边界继续执行其他语句，直到`switch`结束或`break`。

`case`标号必须是整型常量表达式，如果两个`case`有相同的值，会导致编译错误。

对于`switch`结构，只能在它的最后一个`case`标号或`default`后定义变量，避免出现跳过变量的定义和初始化的情况。

# while

在循环条件中定义的变量，每次循环里都要经历创建和撤销的过程。 

# for

可以省略`for`语句的某些部分，也可以在`for`语句头中有多个定义。 

# do while

`do while`语句总以分号结束。

# break

break用来结束最近的`while`、`do while`、`for`或`switch`语句。 

# continue

`continue`导致最近的循环语句的当前迭代提前结束。 

# goto

`label`与变量名及其他标识符一样，不能重名。

`goto`语句和获得所转移的控制权的标号的语句必须在同一个函数内。

`goto`不能跨越变量的定义语句往前跳转，如果`goto`和将跳转的标号之间定义变量，则必须放在一个块语句中。（但是在后面的`label`中，变量仍不可见）。

`goto`向后跳转回到一个变量定义之前，系统会撤销这个变量，重新创建。

# try和异常处理

如果不存在处理该异常的`catch`子句，程序的运行就要跳转到`terminate`的标准库函数。 

# 使用预处理器进行调试

可使用`NDEBUG`预处理变量实现有条件的调试代码。

```c++
#ifdef NDEBUG

#endif
```

# 导航

[目录](README.md)

上一章：[6. 语句](6. 语句.md)

下一章：
