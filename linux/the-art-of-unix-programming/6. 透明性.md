<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [研究实例](#%E7%A0%94%E7%A9%B6%E5%AE%9E%E4%BE%8B)
- [6.2 为透明性和可显性而设计](#62%C2%A0%E4%B8%BA%E9%80%8F%E6%98%8E%E6%80%A7%E5%92%8C%E5%8F%AF%E6%98%BE%E6%80%A7%E8%80%8C%E8%AE%BE%E8%AE%A1)
- [6.3 为可维护性而设计](#63%C2%A0%E4%B8%BA%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E8%80%8C%E8%AE%BE%E8%AE%A1)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

如果实际上能预测到程序行为的全部或大部分情况，并能建立简单的心理模型，这个程序就是透明的。

如果软件系统所包含的功能是为了帮助人们对软件建立正确的“做什么、怎样做”的心理模型而设计，那么这个软件就是可显的。对于用户，良好的文档有助于提高可显性；对于程序员，良好的变量和函数名有利于提高可显性。

GCC由一系列处理阶段组成，并由一个驱动程序将其紧密结合在一起。它们是：预处理器、解析器、代码生成器、汇编器和连接器。

# 研究实例
audacity：UI可操作性，易操作性。

fetchmail的-v选项：防弹程序，可显性。
不要让调试工具仅仅成为时候追加或者用后就束之高阁的东西。他们是通往代码的窗口：不要只在墙上造出粗糙的洞，要整修这些洞并装上窗。如果打算让代码一直可被维护，就必须让光照进去。

GCC：预处理器、解析器、代码生成器、汇编器和连接器。前三个阶段的可读文本流。可以监视中间步骤，有利于回归测试。

kmail：显示过程信息。让你对状态充分了解。让UI沉默只做对了一半，真正聪明的是找到一个方法，可以访问具体细节，但又不让他们太显眼

SNG：与PNG之间进行无缝、无损转换。用户可以直接编辑SNG纯文本文件，而不是PNG文件。sng本身程序代码不容易理解，但是通过让PNG的全部内容可显，提高了程序中较大系统的透明性。

Terminfo：使用Unix文件系统作为数据库是一种策略，对数据库要求简单的其他应用程序可以效仿并从中受益。

Freeciv：数据文件的聚合、存储、使用，修正。因为只读，所以不会蠕变

# 6.2 为透明性和可显性而设计

要追求代码的透明，最有效的方法最简单，就是不要在具体操作的代码上叠放太多的抽象层。

透明性和可显性主要是设计的特性，而不是代码的特性。以下问题需要好好思考：

1. 程序调用层次中最大静态深度是多少？大于4，就要当心。  
2. 代码是否具有强大的、明显的不变性质？  
3. 每个API中的各个函数是否正交？是否存在大多的特征标志？  
4. 是否存在一些顺手可用的关键数据或全局唯一的记录器，捕获了系统的高层级状态？  
5. 程序的数据结构或分类和它们说代表的外部实体之间，是否存在清晰的一对一映射？  
6. 是否容易找到给定函数的代码部分？  
7. 代码增加了特殊情况还是避免了特殊情况？  
8. 代码中有多少个magic number？  

# 6.3 为可维护性而设计
如果作者以外的其他人能够顺利地理解和修改软件，那么它就是可维护的。

Keep it simple！

另一个办法：包含开发者手册，发布源码的同时包括指导文档，简略描述代码的关键数据结构和算法。

# 导航

[目录](README.md)

上一章：[5. 文本化](5. 文本化.md)

下一章：[7. 多道程序设计](7. 多道程序设计.md)

