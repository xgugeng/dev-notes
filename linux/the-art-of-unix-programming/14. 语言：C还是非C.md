<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [C](#c)
- [C++](#c)
- [shell](#shell)
- [Perl](#perl)
- [Tcl  Tools  command language](#tcl%C2%A0%C2%A0tools%C2%A0%C2%A0command%C2%A0language)
- [Python](#python)
- [Java](#java)
- [Emacs Lisp](#emacs%C2%A0lisp)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

我的语言的极限便是我世界的极限。

要有效的应用Unix哲学，必须学会C以外的一些语言，尤其是脚本语言。

# C

C可以作为其他语言的基础，来实现其他语言的核心。它的效率接近机器语言。但是容易犯错，开发效率低。

C和C++以增加实现时间和调试时间为代价来优化效率。

而现在，经济方面的优先选择变成了减少调试时间，延长人对代码的长期维护性。

C和C++的问题在于他们要求程序员自己管理内存。

一篇论文中指出：相比C和C++，脚本语言能够提高一倍的生产力。

参考《The C Programming Language》

# C++

C++面向对象的特性。

向后兼容C，做出了很多妥协；OO没有达到预期。

编译效率以及面向对象和泛型编程的结合是优点。

怪异复杂，鼓励过分复杂的设计是缺点。

如果现有的C++工具包或服务库应用程序提供了强大有效的方法，则考虑用C++。
《The C++ Programming Language》
《C++ Annotation》

# shell

Bourne Shell    Bourne Again Shell

书写小型脚本非常自然快捷。难于处理大型程序

现在胶合层经常用perl和python编写，shell只为简单的包装器和系统启动时的初始化脚本。

《The Unix Programming Language》中高级

shell经常假设引用的程序已经存在，所以可能会产生移植性问题。

# Perl

增强的shell，替代awk

最强的功能是对内置的文本、面向行的数据格式进行模式导向的处理功能。

Perl包含更强大的数据结构。
《Programming Perl》  《Learning Perl》入门

缺点：某些地方丑陋到无法补救；某些部分过于复杂；某些部分必须一成不变的使用。

Perl不使用扩展模块的时候扩展性很好。

Per最佳使用是作为强力工具以供大量设计正则表达式匹配的小型胶合脚本使用。

当程序很大会变得很丑陋。

# Tcl  Tools  command language

Tk工具包
Expect
优点：节俭、紧凑的设计和Tcl解释器的可扩展性。
缺点：古怪的位置分析器和孱弱的数据结构以及命名空间，难用于大型项目。

# Python
和C交流方便；代码块用缩进控制。
《Programming Python》
效率很低，可以在关键地方使用C

优点：鼓励清晰易读的代码，易学易用，还可以扩展到大项目。
缺点：效率低下，速度缓慢。

# Java

GCJ
《Java In A Nutshell》
《Thinking In Java》

非常接近一次编译多次运行的目标。

# Emacs Lisp

脚本语言，用于Emacs文本编辑器的行为编程。

自动内存管理，比大多数语言更雅致、有效。
但消耗资源太多。
    
《The GNU Emacs Lisp Reference Manual》

优点：结合了Lisp，对文本操作非常有效。
缺点：消耗资源太多。

# 导航

[目录](README.md)

上一章：[13. 复杂度](13. 复杂度.md)

下一章：[15章 - 19章](15-19.md)
