<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [带类的C](#%E5%B8%A6%E7%B1%BB%E7%9A%84c)
- [导航](#%E5%AF%BC%E8%88%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

一个合适的工具应该是

（1）具有Simula那样对程序组织的支持：类
（2）产生的程序运行得像BCPL一样快
（3）高度可移植性

# 带类的C

C++的直接前驱，带类的C----关键设计原则----类----运行的时间与空间效率----连接模型----静态（强）类型检查----为什么用C----语法问题-----派生类-----没有虚函数和模版的日子-----访问控制机制-----构造函数和析构函数-----我的工作环境。
	
带类的C被看作是为了描述模块化和并发而做的一种C语言的扩充。带类的C提供了对程序组织的一般性的机制，但不去支持特定的应用领域，所以没有提供内部的复数、字符串或矩阵类型，也没有对并发、持续性、分布式、模式匹配、文件系统操作提供直接支持。
为了能将带类的C应用到C可以用到的一切地方，它没有提供运行时检查，但提供了静态类型检查。

1980年的实现中，提供的特征总结如下：

1) 类：一个类就是一个类型，采用编译时的访问控制对实际表示的访问。对于函数成员要描述其完整类型（返回类型、参数类型）。2) 派生类
3) 共用/私用的访问控制
4) 调用和返回函数（后来删除了）
5) 构造函数和析构函数
6) friend类
7) 函数参数的检查和类型转换：静态类型的检查
后来又加入的特征：
8) inline函数
9) 默认参数
10) 赋值运算符的重载
   
对象的分配有三种方式：在堆栈上（作为自动对象），在固定地址（静态对象），自由存储区（在堆，或者说在动态存储区）。

连接模型：继承C语言的头文件技术，并支持了名称空间的隔离。

语法问题：声明结构标志和类型名。
	
派生类：多态性、容器类

保护模型：友元，访问控制修饰符，C++的保护是通过编译时的机制实现的。访问权是由类本身授予，而不是单方面的取用，访问权控制是通过名字实行的，并不依赖于被命名事物的种类。
  
C++的访问控制是为了防止意外事件，而不是防止欺骗。任何程序设计语言，只要它支持对原始存储器的访问，那么数据就处于开放的状态。

运行时的保证：构造函数和析构函数。

次要特征：赋值的重载，默认参数。

一个程序设计语言要服务于两种目的：它为程序员提供一种载体，使他们能描述需要执行的动作；它还提供一组概念，程序员借助它是靠什么东西是能做的。第一方面是要求一种“接近机器”的语言，C语言遵循这种想法。第二种是“接近需要解决的问题”的语言，这使得解的概念可以直接而简洁的描述。C++对C的改进。

C++为什么没有自动垃圾收集：对一个已经被用在实时处理和硬核心系统（如设备驱动）的语言而言，这显然不合适。

# 导航

[目录](README.md)

下一章：[C++的诞生](C++的诞生.md)